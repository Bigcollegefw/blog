[{"content":"添加自动导航系统，控制主角移动 找到这个包安装 创建一个导航网格 想要一个物体不作为障碍物，需要在这个物体上添加组件 对于一个npc，想把它设置为一个障碍物，第一种方式是点NPC后添加这样一个组件 也可以这样设置，这种方式更适合大片区域 实现物体的移动 实现摄像机的跟随 交互功能的实现 对物体进行标签的分类。 添加或者组件 玩家与物体交互，交互过程中所有被交互物体下都会挂一个InteractableObjects.cs的脚本或者子脚本。 这个方法用protected它确保只有子类可以访问这个方法，而外部类则不能直接访问。这有助于保护类的内部状态不被外部直接修改。使用了virtual关键字，这意味着它可以在派生类中被重写。virtual关键字允许你在基类中定义一个方法，然后在派生类中使用override关键字来提供特定的实现。 这里真的是孬了，属于是不过脑子，代码不过逻辑。unity是足够严谨的，遇到情况一定要将代码逻辑理清楚。\n实现触碰后交互 PlayerMove里面没有变化。\n解决字体问题 首先新建 需要import下包 创建字体文件，因为原来的根本拖不过去。 点击没反应，因为需要英文命名。英文命名为ICE，前面那个Aa是一个标。保存出来的是 然后就是摆UI，我感觉这部分就是在UI里面找组件来搭建。放到一个夫物体上然后设置下bottom，缩放就跟页面。 通过代码控制UI的显示与隐藏 NPCObject 这里一定要命好名，贼坑一点是我之前命好了后来关了结果全没保存，找了以早上空指针异常。长记性了。 首先在PlayerMove.cs中实现一下点击到ui页面玩家不会移动，更改一处即可 实现UI的脚本逻辑。\npublic class DialogueUI : MonoBehaviour { public TextMeshProUGUI nameText; public TextMeshProUGUI contentText; private Button continueButton; // 改成public方便在unity中添加内容 public List\u0026lt;string\u0026gt; contentList; int contentIndex = 0; private void Start() { // 都是这个this.transform下的子物体,这里相当于给nameText赋值 nameText = transform.Find(\u0026#34;NameText\u0026#34;).GetComponent\u0026lt;TextMeshProUGUI\u0026gt;(); //给文本内容赋值,这里赋值后，contexlist里的索引为0的值就显示不出来了。 contentText = transform.Find(\u0026#34;ContentText\u0026#34;).GetComponent\u0026lt;TextMeshProUGUI\u0026gt;(); // 找到这个按钮的组件，按钮组件应该就可以点击 continueButton = transform.Find(\u0026#34;ContinueButton\u0026#34;).GetComponent\u0026lt;Button\u0026gt;(); // 给这个按钮添加一个事件监听 continueButton.onClick.AddListener(this.OnContinueButtonClick); //一开始就直接隐藏，这才符合逻辑 Hide(); } //提供show方法的重载方法 public void Show() { gameObject.SetActive(true); } //这两个方法是二选一的 public void Show(string name, string[] context) { nameText.text = name; //使用一个字符串列表 contentList = new List\u0026lt;string\u0026gt;(); //往列表里添加内容 contentList.AddRange(context); contentText.text = contentList[0]; gameObject.SetActive(true); } public void Hide() { //gameObject是指当前挂载了DialogueUI脚本的游戏对象 gameObject.SetActive(false); } // Button的监听的事件 private void OnContinueButtonClick() { //判断是否超过了，超过就不显示了，不判断还显示就报空指针 contentIndex++; if (contentIndex \u0026gt;= contentList.Count) { Hide(); // 这里重置下索引数。保证每次对话哦都能正常显示 contentIndex = 0; return; } contentText.text = contentList[contentIndex]; } } 以下是这些方法可能的执行顺序：这里直接问ai了，unity的许多方法什么时候执行\nStart()：当对话界面的游戏对象被创建时执行。 Show()：当需要显示对话界面时执行。 Show(string name, string[] context)：紧接着Show()方法执行，用于设置对话内容。 OnContinueButtonClick()：当玩家点击继续按钮时，这个方法会被调用，用于显示下一段对话或隐藏对话界面。 Hide()：当所有对话内容都显示完毕，或者需要手动隐藏对话界面时执行。 通过单例模式改写 就改了前面一点点\npublic class DialogueUI : MonoBehaviour { //创建了一个静态的属性，有get和set方法 public static DialogueUI Instance { get; private set; } private TextMeshProUGUI nameText; private TextMeshProUGUI contentText; private Button continueButton; // 改成public方便在unity中添加内容测试,后面针对到具体人物显示的时候改为私有方法 private List\u0026lt;string\u0026gt; contentList; int contentIndex = 0; //单例属性都在Awake()里面初始化 private void Awake() { //判断是否存在两个DialogueUI，单例模式在场景只存在一个DialogueUI。 //如果Instance不是现在这个，只需要保留一个，直接将这个删掉。 if (Instance != null \u0026amp;\u0026amp; Instance != this) { Destroy(this.gameObject);return; } Instance = this; } private void Start() { // 都是这个this.transform下的子物体,这里相当于给nameText赋值 nameText = transform.Find(\u0026#34;NameText\u0026#34;).GetComponent\u0026lt;TextMeshProUGUI\u0026gt;(); //给文本内容赋值,这里赋值后，contexlist里的索引为0的值就显示不出来了。 contentText = transform.Find(\u0026#34;ContentText\u0026#34;).GetComponent\u0026lt;TextMeshProUGUI\u0026gt;(); // 找到这个按钮的组件，按钮组件应该就可以点击 continueButton = transform.Find(\u0026#34;ContinueButton\u0026#34;).GetComponent\u0026lt;Button\u0026gt;(); // 给这个按钮添加一个事件监听 continueButton.onClick.AddListener(this.OnContinueButtonClick); Hide(); } //提供show方法的重载方法 public void Show() { gameObject.SetActive(true); } public void Show(string name, string[] context) { nameText.text = name; //使用一个字符串列表 contentList = new List\u0026lt;string\u0026gt;(); //往列表里添加内容 contentList.AddRange(context); contentText.text = contentList[0]; gameObject.SetActive(true); } public void Hide() { //gameObject是指当前挂载了DialogueUI脚本的游戏对象 gameObject.SetActive(false); } // Button的监听的事件 private void OnContinueButtonClick() { //判断是否超过了，超过就不显示了，不判断还显示就报空指针 contentIndex++; if (contentIndex \u0026gt;= contentList.Count) { Hide(); // 这里重置下索引数。保证每次对话哦都能正常显示 contentIndex = 0; return; } contentText.text = contentList[contentIndex]; } } public class NPCObject : InteractableObject { public string NPCname; public string[] contentList; protected override void Interact() { DialogueUI.Instance.Show(name, contentList); } } 添加武器 添加走路动画和攻击动画 如果出现以下这种情况，则可能是父物体里面进行了缩放 攻击伤害范围判定 在关键帧的地方勾选或者取消Mesh Collider组件即可。\n挥舞武器 Weapon中\nusing System.Collections; using System.Collections.Generic; using UnityEngine; public class Weapon : MonoBehaviour { //伤害 public int attackValue; public virtual void Attack() { } } ScytheWeapon中\npublic class ScytheWeapon : Weapon { //这里设置一个常量来存储IsAttack这个字符串。 public const string ANIM_PARM_ISATTACK = \u0026#34;IsAttack\u0026#34;; //获得这个动画状态机 private Animator anim; private void Start() { anim = GetComponent\u0026lt;Animator\u0026gt;(); } private void Update() { if (Input.GetKeyDown(KeyCode.Space)) { Attack(); } } public override void Attack() { //这是没有定义常量的写法 //anim.SetTrigger(\u0026#34;IsAttack\u0026#34;); anim.SetTrigger(ANIM_PARM_ISATTACK); } private void OnTriggerEnter(Collider other) { if(other.tag == \u0026#34;Enemy\u0026#34;) { //TODO，这个注释表示还没做完 print(\u0026#34;Trigger with \u0026#34; + other.name); } } } 武器的攻击碰触检测：这里需要设置Trigger，给武器添加一个刚体，接着代码实现就可。 开发PlayerAttack来控制主角攻击\npublic class PlayerAttack : MonoBehaviour { //指定武器栏 public Weapon weapon; private void Start() { } //这里有个好处就是，以后不管换什么武器，我们都只需要调用父类的Attack方法 void Update() { if(weapon != null \u0026amp;\u0026amp; Input.GetKeyDown(KeyCode.Space)) { weapon.Attack(); } } //装载 public void LoadWeapon(Weapon weapon) { this.weapon = weapon; } //卸下 public void UnloadWeapon() { weapon = null; } } 开发标枪武器 给标枪添加一个刚体的属性 先清楚这些之间的关系 正确示范： 有两个错误的案例\nQuaternion.identity是一个静态的Quaternion值，它代表了一个无旋转的状态。 零向量是一个具有大小为零且没有方向的向量。在Unity中，Vector3.zero提供了一个方便的方式来表示这种概念。 transform.position：这是当前脚本所附着的游戏对象的位置。transform是Unity中所有游戏对象都有的一个组件，包含位置、旋转和缩放信息。这里表示新实例化的子弹将出现在与当前游戏对象相同的位置。 transform.rotation：这是当前脚本所附着的游戏对象的旋转。新实例化的子弹将继承这个旋转，错误点在此，这里会使得所有的投的标枪都会有同样的角度 .velocity：这是Rigidbody组件的一个属性，用于设置或获取刚体的当前速度。 Vector3.forward：这是一个表示向前方向的向量（1, 0, 0）。在Unity中，这通常表示沿着局部空间的Z轴正方向。 bulletSpeed：这是一个变量，表示子弹的速度。 Vector3.forward * bulletSpeed：将Vector3.forward乘以bulletSpeed，得到一个具有大小为bulletSpeed且方向向前的速度向量。 完善标枪的发射和销毁 Capsule Collider是一个性能优化和适用于特定形状碰撞检测的工具，而Mesh Collider则提供了更广泛的适用性和更高的碰撞精度。选择哪种碰撞器取决于具体的游戏设计需求和性能考虑。 完善JavnlinWeapon.cs\npublic class JavnlinWeapon : Weapon { public float bulletSpeed; public GameObject bulletPrefab; private GameObject bulletGo; private void Start() { //保持一开始就有一个标枪 SpawnBullet(); } public override void Attack() { //base关键字用来指代当前对象的父类（即超类或基类）的属性、字段或方法。 //base.Attack(); if (bulletGo != null) { //置空父物体 bulletGo.transform.parent = null; bulletGo.GetComponent\u0026lt;Rigidbody\u0026gt;().velocity = transform.forward * bulletSpeed; //射出去了进入贤者状态 bulletGo = null; //0.5s后又充能好了,会再玩家手上在生成一个标枪 Invoke(\u0026#34;SpawnBullet\u0026#34;, 0.5f); } else { return; } } //这是生成标枪的函数 private void SpawnBullet() { //括号里的参数分别为要实例化的物体，物体的位置，物体的角度，都是随着角色的 bulletGo = GameObject.Instantiate(bulletPrefab, transform.position,transform.rotation); //生成的标枪不会自动放在游戏物体下面，等下发射出去又需要将父物体置空，不然会跟着父物体一起旋转 bulletGo.transform.parent = this.transform; } } 给JavelinBullet添加脚本\npublic class JavelinBullet : MonoBehaviour { private Rigidbody rgd; private Collider col; private void Start() { rgd = GetComponent\u0026lt;Rigidbody\u0026gt;(); col = GetComponent\u0026lt;Collider\u0026gt;(); } private void OnCollisionEnter(Collision collision) { //防止标枪碰到玩家后停在原地 if(collision.collider.tag == \u0026#34;Player\u0026#34;) { return; } rgd.velocity = Vector3.zero; //将自身碰撞体设置掉，将col.enabled = false;放置在rgd.isKinematic = true;之前也可以确保物体立即停止与其他物体的物理交互，避免在设置运动学模式生效之前的瞬间发生额外的物理计算 col.enabled = false; //这样就不再受到物理的一些力的影响 rgd.isKinematic = true; //销毁 Destroy(this.gameObject, 1f); } } 表示您尝试设置一个运动学刚体的线性速度，这在Unity中是不允许的。 要解决这个问题，您需要在设置Rigidbody为运动学模式之前停止速度。but并未解决。 希望这个bug不会滚起来。\n射不中自动销毁的实现 我发现这个标枪只有在碰到物体后会自动销毁。所以我自己做了完善 这里需要保证下每次invoke函数使用前都确保下已经取消之前的调用，以防重复调用，然后不成功。 这里这样写了之后，有一个判断标枪是否被投掷的过程，所以在后面标枪作为打怪掉落物品的时候，并不会自己因为触碰到什么碰撞物后销毁。真的是前后呼应，有先见之明啊，因为这段代码是我自己改的，后面课程上面提供的两种方法分别是1.搞两种标枪，一种武器，一种专门掉落物，\n2.通过标签区分现在处于什么状态。 添加标签， 设置掉落的物体的标签，这一步对于后面玩家捡起掉落物品都需要进行标签判断有关系，不管用不用这种方法都最好加上 放在SpawnBullet下面是因为这个是生成标枪的函数，玩家扔出标枪时候手上会生成，在敌人掉落的物品处也会生成。生成的那一刹，就会有这个脚本的执行。所以在生成的函数下面加判断即可。 开发物体菜单 新建东西 使用ScriptObject来进行游戏内物品的管理\nusing System.Collections; using System.Collections.Generic; using UnityEngine; //加入这个特性后，就可以在下面找到这个选项新建 [CreateAssetMenu()] public class TestScriptObject : ScriptableObject { public int age; public string name; public string[] list; } 我们这里新建的文件都移动到下面的目录下，这就是我们游戏物体的一些属性。 创建itemSO物品数据类 using System; using System.Collections; using System.Collections.Generic; using UnityEngine; //这个注解是使得可能直接创建一个ItemSO的文件 [CreateAssetMenu()] public class ItemSO : ScriptableObject { public string name; public ItemType itemType; public string description; public List\u0026lt;ItemProperty\u0026gt; propertyList; public Sprite icon; public GameObject prefab; } public enum ItemType { //武器 Weapon, //消耗品 Consumable } //表示一个类可以序列化，序列化后就可以进行数据存储 [Serializable] public class ItemProperty { public ItemPropertyType propertyType; public int value; } public enum ItemPropertyType { HPValue, EnergyValue, MentalValue, SpeedValue, AttackValue } 创建ItemDBSO类 DB就是数据库的意思，这里是整合ItemSO到一个列表的类 创建专门管理Item的空物体Manger 管理所有的Item信息，也可以给其他的脚本访问得到我们的Item信息。 ItemDBManager.cs 优化一下标签 创建这样一个类，之后我们需要在之前的代码用到这些东西的地方改成Tag.ENEMY就可以了。\npublic class Tag : MonoBehaviour { public const string ENEMY = \u0026#34;Enemy\u0026#34;; public const string PLAYER = \u0026#34;Player\u0026#34;; } 开发敌人掉落物体同时实现敌人的移动 掉落的物体 新建一个模型，挂一个Enemy脚本 Enemy.cs using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.AI; public class Enemy : MonoBehaviour { public enum EnemyState { NormalState, FightingState, MovingState, RestingState } private EnemyState state = EnemyState.NormalState; private EnemyState childState = EnemyState.RestingState; private NavMeshAgent enemyAgent; public int HP = 100; //设置休息状态的时间 public float restTime = 2; public float restTimer = 0; void Start() { enemyAgent = GetComponent\u0026lt;NavMeshAgent\u0026gt;(); } void Update() { if(state == EnemyState.NormalState) { if(childState == EnemyState.RestingState) { //设置经过的时间 restTimer += Time.deltaTime; if(restTimer \u0026gt; restTime) { Vector3 randomPositon = FindRandomPosition(); enemyAgent.SetDestination(randomPositon); childState = EnemyState.MovingState; } }else if(childState == EnemyState.MovingState) { if(enemyAgent.remainingDistance \u0026lt;= 0) { restTimer = 0; childState = EnemyState.RestingState; } } } //测试用的 if(Input.GetKeyDown(KeyCode.Space)) { TakeDamage(30); } } Vector3 FindRandomPosition() { //在x和z方向上给一个随机的速度， Vector3 randomDir = new Vector3(Random.Range(-1,1f),0,Random.Range(-1,1f)); return transform.position + randomDir.normalized * Random.Range(2,5); } // 添加受伤方法 public void TakeDamage(int damage) { HP -= damage; if (HP \u0026lt;= 0) { //销毁之前爆装备，在物品列表里随机爆随机数量的随机物品，对itemDB持有一个引用因为它保存了所有的物品信息 //将Collider禁用掉，防止敌人与掉落的物体碰撞 GetComponent\u0026lt;Collider\u0026gt;().enabled = false; int count = Random.Range(0, 4); for(int i = 0; i \u0026lt; count; i++) { //这里使用了ItemDBManager方法 ItemSO item = ItemDBManager.Instance.GetRandomItem(); //生成的物品在当前位置，不需要旋转 GameObject.Instantiate(item.prefab,transform.position,Quaternion.identity); //爆装的随机装备有初速度由刚体属性实现，isKinematic取消，UseGravity勾选上。 } Destroy(this.gameObject); } } } 爆装的随机装备有初速度由刚体属性实现，isKinematic取消，UseGravity勾选上。\n完善掉落功能 掉落的武器一直不在指定的位置，可能是动画的影响 进行一下更改 实现爆出物体的交互 给爆出的物体添加脚本 爆出的物体下面应该有两个东西，一个是PickableObject脚本，一个是Interactable标签 优化标枪武器和子弹的爆出逻辑 给玩家 using System.Collections; using System.Collections.Generic; using Unity.VisualScripting; using UnityEngine; public class PlayerPick : MonoBehaviour { private void OnCollisionEnter(Collision collision) { // 先进行标签判断，因为标签判断节约性能，因为npc也有这个属性所以需要找有无PickableObject这个组件 //if(collision.gameObject.CompareTag(Tag.INTERACTABLE)) //{ PickableObject po = collision.gameObject.GetComponent\u0026lt;PickableObject\u0026gt;(); if(po != null) { Debug.Log(\u0026#34;执行了PlayerPick\u0026#34;); InventoryManager.Instance.AddItem(po.itemSO); Destroy(po.gameObject); } //} } } 这个地方我怎么都实现不了这个碰撞，回头再来收拾你。 在几天十年后 创建捡起物体的背包类，将这个组件挂在Manager下 主角攻击功能 给标枪武器添加伤害 JavelinBullet.cs下 镰刀武器攻击功能 敌人的批量生成 背包UI UI大致的代码![[Pasted image 20241003135900.png]] 可以去对照之前的版本，主要就是改了下GameObject uiGameObject,因为这个代码被移到父级了。所以在Start方法里面的路径都要改一下。\nusing System.Collections; using System.Collections.Generic; using TMPro; using UnityEngine; using UnityEngine.UI; public class DialogueUI : MonoBehaviour { //创建了一个静态的属性，有get和set方法 public static DialogueUI Instance { get; private set; } private TextMeshProUGUI nameText; private TextMeshProUGUI contentText; private Button continueButton; // 改成public方便在unity中添加内容测试,后面针对到具体人物显示的时候改为私有方法 private List\u0026lt;string\u0026gt; contentList; int contentIndex = 0; private GameObject uiGameObject; //单例属性都在Awake()里面初始化 private void Awake() { //判断是否存在两个DialogueUI，单例模式在场景只存在一个DialogueUI。 //如果Instance不是现在这个，只需要保留一个，直接将这个删掉。 if (Instance != null \u0026amp;\u0026amp; Instance != this) { Destroy(this.gameObject);return; } Instance = this; } private void Start() { // 都是这个this.transform下的子物体,这里相当于给nameText赋值 nameText = transform.Find(\u0026#34;UI/NameText\u0026#34;).GetComponent\u0026lt;TextMeshProUGUI\u0026gt;(); //给文本内容赋值,这里赋值后，contexlist里的索引为0的值就显示不出来了。 contentText = transform.Find(\u0026#34;UI/ContentText\u0026#34;).GetComponent\u0026lt;TextMeshProUGUI\u0026gt;(); // 找到这个按钮的组件，按钮组件应该就可以点击 continueButton = transform.Find(\u0026#34;UI/ContinueButton\u0026#34;).GetComponent\u0026lt;Button\u0026gt;(); // 给这个按钮添加一个事件监听 continueButton.onClick.AddListener(this.OnContinueButtonClick); uiGameObject = transform.Find(\u0026#34;UI\u0026#34;).gameObject; Hide(); } //提供show方法的重载方法 public void Show() { uiGameObject.SetActive(true); } public void Show(string name, string[] context) { nameText.text = name; //使用一个字符串列表 contentList = new List\u0026lt;string\u0026gt;(); //往列表里添加内容 contentList.AddRange(context); contentText.text = contentList[0]; uiGameObject.SetActive(true); } public void Hide() { //gameObject是指当前挂载了DialogueUI脚本的游戏对象 uiGameObject.SetActive(false); } // Button的监听的事件 private void OnContinueButtonClick() { //判断是否超过了，超过就不显示了，不判断还显示就报空指针 contentIndex++; if (contentIndex \u0026gt;= contentList.Count) { Hide(); // 这里重置下索引数。保证每次对话哦都能正常显示 contentIndex = 0; return; } contentText.text = contentList[contentIndex]; } } InventoryUI Scroll是一种带有滚动条的UI对象\n进度条不显示的解决方法 禁用自动均匀分配位置 保持滚动条与内容长度一致 布置ui 通过点击的方式捡起掉落物品 就是简单改了一下交互的方法，那我之前那个没有办法实现的碰撞捡起，只能先用这种点击捡起方式过渡下了www。 ","date":"2024-10-06T00:00:00Z","image":"https://s21.ax1x.com/2024/09/05/pAZDb9O.jpg","permalink":"https://bigcollegefw.github.io/blog/p/6/","title":"从零开始游戏开发的之路"}]